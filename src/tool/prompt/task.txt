Launch a subagent to handle complex, multi-step tasks autonomously.

Each task spawns a full, independent LLM session with its own context window. The subagent makes its own tool calls and returns a single result message when done.

# Available subagent types

- **explore** — Fast codebase exploration specialist. Use for: finding files by patterns, searching code for keywords, understanding project structure, tracing import/export chains, answering questions about the codebase. Read-only. (Tools: read, glob, grep, list, bash)
- **architect** — Feature architecture designer. Use for: analyzing codebase patterns and conventions, designing implementation blueprints with specific files to create/modify, component designs, data flows, and build sequences. Read-only. (Tools: read, glob, grep, list, bash)
- **reviewer** — Code review specialist. Use for: finding bugs, logic errors, security vulnerabilities, code quality issues, and adherence to project conventions. Read-only. (Tools: read, glob, grep, list, bash)
- **researcher** — Deep research agent. Use for: investigating unfamiliar libraries, combining local code analysis with web search, producing research reports with sources. Read-only with web access. (Tools: read, glob, grep, list, bash, websearch, codesearch, webfetch)
- **guide** — kkcode self-help guide. Use when the user asks "How do I...", "Can kkcode...", "What tool should I use for..." questions about kkcode itself. Searches kkcode source code for accurate answers. Read-only. (Tools: read, glob, grep, list, webfetch, websearch)
- **security-reviewer** — Security audit specialist. Use for: OWASP Top 10 checks, hardcoded secret scans, dependency audits, authentication/authorization reviews. Read-only. (Tools: read, glob, grep, list, bash)
- **tdd-guide** — TDD specialist. Use for: guiding test-driven development workflows (scaffold→RED→GREEN→REFACTOR), writing failing tests first, targeting 80%+ coverage. Full access. (Tools: read, write, edit, bash, glob, grep, list)
- **build-fixer** — Build error resolver. Use for: diagnosing build failures, identifying root causes (type errors, missing imports, dependency conflicts), applying fixes, verifying builds. Full access. (Tools: read, write, edit, bash, glob, grep, list)
- **(default)** — Full-capability build agent. Use for: complex multi-file changes, refactoring, test writing, any task requiring file mutations.

# When to Use This Tool

Use `task` when the work:
- Requires multiple tool calls and autonomous reasoning (e.g. "refactor module X", "write tests for Y")
- Benefits from an independent context window (protects main conversation from result noise)
- Involves code review, deep research, or broad codebase exploration
- Can be parallelized — launch multiple independent tasks simultaneously

<example>
User: "Please investigate how authentication works in this project"
→ Launch task with subagent_type="explore", prompt="Trace the authentication flow..."

Reasoning: Open-ended exploration that may require many file reads. Subagent keeps main context clean.
</example>

<example>
User: "Refactor the database module and update all tests"
→ Launch task with default subagent, prompt="Refactor src/db/... and update test/db/..."

Reasoning: Complex multi-file change requiring autonomous execution.
</example>

<example>
User: "Review this PR for security issues"
→ Launch task with subagent_type="reviewer", prompt="Review all changed files for..."

Reasoning: Code review benefits from dedicated context and structured output.
</example>

# When NOT to Use — use the appropriate tool directly instead

Do NOT use `task` as a wrapper for simple operations:
- Reading a specific file → use `read` directly
- Searching for a specific class/function → use `grep` or `glob` directly
- Running a shell command → use `bash` directly
- Making a small file edit → use `edit` directly
- Creating a file → use `write` directly
- Any single-step operation → use the appropriate tool directly

<example>
BAD: task(prompt="Read the file src/config.mjs and tell me what it exports")
GOOD: read(path="src/config.mjs") — then analyze the content yourself

BAD: task(prompt="Search for all files named *.test.js")
GOOD: glob(pattern="**/*.test.js")
</example>

# Parameters

- **prompt** (required): Detailed task description with ALL necessary context. The subagent starts fresh — it cannot see your conversation history. Include:
  - What to do (specific instructions)
  - Why (context for decision-making)
  - Whether to write code or just research
  - Key file paths or patterns to start with

- **subagent_type** (optional): One of "explore", "architect", "reviewer", "researcher", or omit for default build agent.

- **run_in_background** (optional): Set to true to run as a background worker. Returns a task_id immediately — use `background_output` to check results later.

# Important Behaviors

- Each `task` call spawns a full LLM session — it is expensive and slow. Use it deliberately.
- The subagent's result is NOT visible to the user. You MUST send a text message summarizing the result.
- You can launch multiple tasks in parallel for independent work — this is a key advantage.
- Avoid duplicating work that subagents are already doing. If you delegated research, don't also search yourself.
- Provide clear, self-contained prompts. The subagent has no access to your conversation context.
- Clearly state whether you expect the agent to write code or just do research, since it cannot infer your intent.